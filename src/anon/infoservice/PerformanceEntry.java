package anon.infoservice;

import java.text.NumberFormat;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Calendar;
import java.util.Vector;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Document;

import anon.util.XMLUtil;
import anon.util.XMLParseException;
import anon.util.IXMLEncodable;

public class PerformanceEntry extends AbstractDatabaseEntry implements IXMLEncodable
{
	private static final String XML_ATTR_HOUR = "hour";
	private static final String XML_ATTR_DAY = "day";
	private static final String XML_ATTR_ID = "id";
	private static final String XML_ATTR_TIME = "time";
	
	private static final String XML_ELEMENT_LAST_TEST = "LastTest";
	private static final String XML_ELEMENT_CURRENT_HOURLY_DATA = "CurrentHourlyData";
	private static final String XML_ELEMENT_HOURLY_DATA = "HourlyData";
	private static final String XML_ELEMENT_DAILY_DATA = "DailyData";
	private static final String XML_ELEMENT_WEEKLY_DATA = "WeeklyData";
		
	public static final long LAST_TEST_DATA_TTL = 5 * 60 * 1000;
	
	private String m_strCascadeId;
	private Calendar m_cal = Calendar.getInstance();
	
	private long m_lastUpdate;
	private long m_serial;
	
	private long m_lastTestTime;
	
	private PerformanceAttributeEntry[][] m_speed = new PerformanceAttributeEntry[7][24];
	private PerformanceAttributeEntry[][] m_delay = new PerformanceAttributeEntry[7][24];
	
	private long m_lastTestAverageSpeed = 0;
	private long m_lastTestAverageDelay = 0;
		
	public static final String XML_ELEMENT_CONTAINER_NAME = "PerformanceInfo";
	
	public static final int PERFORMANCE_ENTRY_TTL = 1000*60*60; // 1 hour
	
	public static final String XML_ELEMENT_NAME = "PerformanceEntry";	
	
	public PerformanceEntry(String a_strCascadeId, long a_lExpireTime)
	{	
		super(a_lExpireTime);
		
		m_strCascadeId = a_strCascadeId;
		
		m_lastUpdate = System.currentTimeMillis();
		m_serial = System.currentTimeMillis();
	}
	
	public PerformanceEntry(Element a_entry) throws XMLParseException
	{
		super(System.currentTimeMillis() + PERFORMANCE_ENTRY_TTL);
		
		XMLUtil.assertNodeName(a_entry, XML_ELEMENT_NAME);
		
		m_strCascadeId = XMLUtil.parseAttribute(a_entry, XML_ATTR_ID, "");
		
		if(m_strCascadeId == "")
		{
			throw new XMLParseException(XML_ELEMENT_NAME + ": invalid id");
		}
		
		Node elemCurrentData = XMLUtil.getFirstChildByName(a_entry, XML_ELEMENT_CURRENT_HOURLY_DATA);
		if(elemCurrentData == null)
		{
			throw new XMLParseException(XML_ELEMENT_NAME + ": Could not find node " + XML_ELEMENT_CURRENT_HOURLY_DATA);
		}
		
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		Node elemDelay = XMLUtil.getFirstChildByName(elemCurrentData, PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_DELAY);
		if(elemDelay == null)
		{
			throw new XMLParseException(XML_ELEMENT_NAME + ": Could not find node " + PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_DELAY);
		}
		m_delay[dayOfWeek][hour] = new PerformanceAttributeEntry(elemDelay);
		
		Node elemSpeed = XMLUtil.getFirstChildByName(elemCurrentData, PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_SPEED);
		if(elemSpeed == null)
		{
			throw new XMLParseException(XML_ELEMENT_NAME + ": Could not find node " + PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_SPEED);
		}
		m_speed[dayOfWeek][hour] = new PerformanceAttributeEntry(elemSpeed);
		
		m_lastUpdate = System.currentTimeMillis();
		m_serial = System.currentTimeMillis();
	}
	
	public String getId()
	{
		return m_strCascadeId;
	}

	public long getLastUpdate()
	{
		return m_lastUpdate;
	}
	
	public long getVersionNumber() 
	{
		return m_serial;
	}
	
	public long getLastTestTime()
	{
		return m_lastTestTime;
	}
	
	public void addValue(String a_attributeName, PerformanceAttributeEntry[][] a_entries, long a_timestamp, long a_value)
	{
		PerformanceAttributeEntry entry = null;
		
		Calendar cal = Calendar.getInstance();
		cal.setTimeInMillis(a_timestamp);
		
		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
		int hour = cal.get(Calendar.HOUR_OF_DAY);
		
		entry = a_entries[dayOfWeek][hour];
		if(entry == null)
		{
			a_entries[dayOfWeek][hour] = entry = new PerformanceAttributeEntry(a_attributeName);
		}

		entry.addValue(a_timestamp, a_value);
		
		m_lastUpdate = a_timestamp;
	}
	
	public long addData(String a_attributeName, PerformanceAttributeEntry[][] a_entries, Hashtable a_data) 
	{
		PerformanceAttributeEntry entry = null;
		
		long lAverageFromLastTest = -1;
		
		if(a_data.size() > 0)
		{
			Long timestamp = null;
			Enumeration e = a_data.keys();
		
			while(e.hasMoreElements())
			{
				timestamp = (Long) e.nextElement();
				long value = ((Long) a_data.get(timestamp)).longValue();
				
				lAverageFromLastTest += value;
				
				Calendar cal = Calendar.getInstance();
				cal.setTimeInMillis(timestamp.longValue());
				
				int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);
				int hour = cal.get(Calendar.HOUR_OF_DAY);
				
				entry = a_entries[dayOfWeek][hour];
				if(entry == null)
				{
					a_entries[dayOfWeek][hour] = entry = new PerformanceAttributeEntry(a_attributeName); 
				}
				
				entry.addValue(timestamp.longValue(), value);
			}
			lAverageFromLastTest /= a_data.size();
			
			m_lastTestTime = timestamp.longValue();
			m_lastUpdate = timestamp.longValue();
		}
		else
		{
			m_lastUpdate = System.currentTimeMillis();
		}
		
		return lAverageFromLastTest;
	}
	
	public long addSpeedData(Hashtable a_data) 
	{
		return m_lastTestAverageSpeed = addData(PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_SPEED, m_speed, a_data);
	}
		
	public long addDelayData(Hashtable a_data)
	{
		return m_lastTestAverageDelay = addData(PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_DELAY, m_delay, a_data);
	}
	
	public void addSpeedValue(long a_timestamp, long a_value)
	{
		addValue(PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_SPEED, m_speed, a_timestamp, a_value);
	}
	
	public void addDelayValue(long a_timestamp, long a_value)
	{
		addValue(PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_DELAY, m_delay, a_timestamp, a_value);
	}
	
	public long getDelayFromLastTest()
	{
		return m_lastTestAverageDelay;
	}
	
	public long getSpeedFromLastTest()
	{
		return m_lastTestAverageSpeed;
	}
	
	public PerformanceAttributeEntry getCurrentSpeedEntry()
	{
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		return m_speed[dayOfWeek][hour];
	}
	
	public PerformanceAttributeEntry getCurrentDelayEntry()
	{
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		return m_delay[dayOfWeek][hour];		
	}
	
	public void overrideDailyAverageSpeed(long a_lSpeed)
	{
		PerformanceAttributeEntry entry = null;
		
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		if(m_speed[dayOfWeek][hour] == null)
		{
			m_speed[dayOfWeek][hour] = entry = new PerformanceAttributeEntry(PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_SPEED);
		}
		
		entry.overrideAverageValue(a_lSpeed);
	}
	
	public void overrideDailyAverageDelay(long a_lDelay)
	{
		PerformanceAttributeEntry entry = null;
		
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		if(m_delay[dayOfWeek][hour] == null)
		{
			m_delay[dayOfWeek][hour] = entry = new PerformanceAttributeEntry(PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_DELAY);
		}
		
		entry.overrideAverageValue(a_lDelay);
	}
	
	public long getAverageSpeed()
	{
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		if(m_speed[dayOfWeek][hour] == null)
		{
			return -1;
		}
		else
		{
			return m_speed[dayOfWeek][hour].getAverageValue();
		}
	}
	
	public long getAverageDelay()
	{
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		int hour = m_cal.get(Calendar.HOUR_OF_DAY);
		
		if(m_delay[dayOfWeek][hour] == null)
		{
			return -1;
		}
		else
		{
			return m_delay[dayOfWeek][hour].getAverageValue();
		}
	}
	
	public boolean isInvalid()
	{
		return (getAverageSpeed() == -1 || getAverageDelay() == -1);
		
	}
	
	public String delayToHTML()
	{
		return toHTML(m_delay, "ms");
	}
	
	public String speedToHTML()
	{
		return toHTML(m_speed, "kbit/sec");
	}
	
	public String toHTML(PerformanceAttributeEntry[][] a_entries, String a_unit)
	{
		String htmlData = "<table width=\"40%\">" +
				"<tr>" +
				"<th width=\"25%\">Hour</th>" +
				"<th>Average</th>" +
				"<th>Min</th>" +
				"<th>Max</th>" +
				"<th>Std. Deviation</th><th>Last Test</th></tr>";
		
		int dayOfWeek = m_cal.get(Calendar.DAY_OF_WEEK);
		
		for(int hour = 0; hour < 24; hour++)
		{
			htmlData += "<tr>" +
					"<td CLASS=\"name\">" + hour + ":00 - " + ((hour + 1) % 24) + ":00</td>";
			
			PerformanceAttributeEntry entry = a_entries[dayOfWeek][hour];
			
			if(entry == null)
			{
				htmlData += "<td colspan=\"5\" align=\"center\">No data available</td>";
			}
			else
			{
				htmlData += "<td>" + entry.getAverageValue() + " " + a_unit + "</td>" +
					"<td>" + entry.getMinValue() + " " + a_unit + "</td>" +
					"<td>" + entry.getMaxValue() + " " + a_unit + "</td>" +
					"<td>" + NumberFormat.getInstance(Constants.LOCAL_FORMAT).format(entry.getStdDeviation()) + " " + a_unit + "</td>";
			
				if(hour == m_cal.get(Calendar.HOUR_OF_DAY) && a_entries == m_speed)
				{
					htmlData += "<td>" + m_lastTestAverageSpeed + " " + a_unit + "</td>";
				}
				else if(hour == m_cal.get(Calendar.HOUR_OF_DAY) && a_entries == m_delay)
				{
					htmlData += "<td>" + m_lastTestAverageDelay + " " + a_unit + "</td>";
				}
				else
				{
					htmlData += "<td></td>";
				}
			}
			
			htmlData += "</tr>";
		}
		
		htmlData += "</table>";
		
		return htmlData;
	}
	
	public Element toXmlElement(Document a_doc)
	{
		Element elem = a_doc.createElement(XML_ELEMENT_NAME);
		XMLUtil.setAttribute(elem, XML_ATTR_ID, getId());
		XMLUtil.setAttribute(elem, XML_ATTR_TIME, m_lastTestTime);
		
		Element elemLast = a_doc.createElement(XML_ELEMENT_LAST_TEST);
		XMLUtil.setAttribute(elemLast, PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_DELAY, m_lastTestAverageDelay);
		XMLUtil.setAttribute(elemLast, PerformanceAttributeEntry.PERFORMANCE_ATTRIBUTE_SPEED, m_lastTestAverageSpeed);
		
		Element elemCurrent = a_doc.createElement(XML_ELEMENT_CURRENT_HOURLY_DATA);
		
		// TODO: no available data for this hour -> use another hour?
		if(getCurrentDelayEntry() != null)
		{
			Element elemDelay = getCurrentDelayEntry().toXmlElement(a_doc);
			elemCurrent.appendChild(elemDelay);
		}
		
		if(getCurrentSpeedEntry() != null)
		{
			Element elemSpeed = getCurrentSpeedEntry().toXmlElement(a_doc);
			elemCurrent.appendChild(elemSpeed);
		}
		
		/*if(a_bDisplayWeeklyData)
		{
			Element elemWeeklyData = a_doc.createElement(XML_ELEMENT_WEEKLY_DATA);
		
			for(int i = 0; i < 7; i++)
			{
				Element elemDailyData = a_doc.createElement(XML_ELEMENT_DAILY_DATA);
				XMLUtil.setAttribute(elemDailyData, XML_ATTR_DAY, i);
				elemWeeklyData.appendChild(elemDailyData);
			
				for(int j = 0; j < 24; j++)
				{
					Element elemHourlyData = a_doc.createElement(XML_ELEMENT_HOURLY_DATA);
					XMLUtil.setAttribute(elemHourlyData, XML_ATTR_HOUR, j);
					Element e = m_speed[i][j] != null ? m_speed[i][j].toXmlElement(a_doc) : null;
					Element f = m_delay[i][j] != null ? m_delay[i][j].toXmlElement(a_doc) : null;
					
					if(e != null)
					{
						elemHourlyData.appendChild(e);
					}
					
					if(f != null)
					{
						elemHourlyData.appendChild(f);
					}
				
					elemDailyData.appendChild(elemHourlyData);
				}
			}
			
			elem.appendChild(elemWeeklyData);
		}*/
		
		elem.appendChild(elemLast);
		elem.appendChild(elemCurrent);
		
		return elem;
	}

	class PerformanceAttributeEntry implements IXMLEncodable
	{
		public static final String PERFORMANCE_ATTRIBUTE_DELAY = "Delay";
		public static final String PERFORMANCE_ATTRIBUTE_SPEED = "Speed";
		
		public static final String XML_ATTR_MIN = "min";
		public static final String XML_ATTR_MAX = "max";
		public static final String XML_ATTR_AVERAGE = "average";
		public static final String XML_ATTR_STD_DEVIATION = "stdDeviaton";
		
		public static final String XML_ELEMENT_VALUES = "Values";
		public static final String XML_ELEMENT_VALUE = "Value";
		
		private String m_name;
		
		private long m_lMaxValue;
		private long m_lMinValue;
		private long m_lAverageValue;
		private double m_lStdDeviation;
		
		private Hashtable m_Values = new Hashtable();
		
		public PerformanceAttributeEntry(String a_name)
		{
			m_name = a_name;
		}
		
		public PerformanceAttributeEntry(Node a_node)
		{
			m_name = XMLUtil.parseValue(a_node, "UnknownAttribute");
			
			m_lMinValue = XMLUtil.parseAttribute(a_node, XML_ATTR_MIN, 0);
			m_lMaxValue = XMLUtil.parseAttribute(a_node, XML_ATTR_MAX, 0);
			m_lAverageValue = XMLUtil.parseAttribute(a_node, XML_ATTR_AVERAGE, 0);
			m_lStdDeviation = XMLUtil.parseAttribute(a_node, XML_ATTR_STD_DEVIATION, 0);
		}
		
		public void addValue(long a_lTimeStamp, long a_lValue)
		{
			if (a_lValue <= 0)
			{
				return;
			}
			
			m_Values.put(new Long(a_lTimeStamp), new Long(a_lValue));
			
			long lValues = 0;
			Enumeration e = m_Values.elements();
			while(e.hasMoreElements())
			{
				lValues += ((Long) e.nextElement()).longValue();
			}
			
			m_lAverageValue = lValues / m_Values.size();
			
			// mean squared error
			double mseValue = 0;
			e = m_Values.elements();
			while(e.hasMoreElements())
			{
				mseValue += Math.pow(((Long) e.nextElement()).longValue() - m_lAverageValue, 2);
			}
			
			mseValue /= m_Values.size();
			
			// standard deviation
			m_lStdDeviation = Math.sqrt(mseValue);
			
			if(m_lMinValue == 0)
			{
				m_lMinValue = a_lValue;
			}
			else
			{
				m_lMinValue = Math.min(m_lMinValue, a_lValue);
			}
			
			m_lMaxValue = Math.max(m_lMaxValue, a_lValue);
			
			m_lastUpdate = System.currentTimeMillis();			
		}
		
		public long getAverageValue()
		{
			return m_lAverageValue;
		}
		
		public long getMinValue()
		{
			return m_lMinValue;
		}
		
		public long getMaxValue()
		{
			return m_lMaxValue;
		}
		
		public double getStdDeviation()
		{
			return m_lStdDeviation;
		}
		
		public boolean isInvalid()
		{
			return m_lAverageValue == 0 || m_lAverageValue == -1;
		}
		
		public String getName()
		{
			return m_name;
		}
		
		public void overrideAverageValue(long a_lValue)
		{
			m_lAverageValue = a_lValue;
		}
		
		public Element toXmlElement(Document a_doc)
		{
			Element elem = a_doc.createElement(getName());
			
			XMLUtil.setAttribute(elem, XML_ATTR_MIN, m_lMinValue);
			XMLUtil.setAttribute(elem, XML_ATTR_MAX, m_lMaxValue);
			XMLUtil.setAttribute(elem, XML_ATTR_AVERAGE, m_lAverageValue);
			XMLUtil.setAttribute(elem, XML_ATTR_STD_DEVIATION, m_lStdDeviation);
			
			return elem;
		}
	}
}
